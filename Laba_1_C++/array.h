#ifndef ARRAY_H
#define ARRAY_H

/*Хотілось би додати, що я лишаю коментарі для кращого розуміння коду
Така звичка сформувалась на лабах і в особистій розробці теж вказую
де і що. Тому їх можу бути інколи багато, але намагаюсь краще зрозуміти код
для того, щоб використовувати досвід у розробці на STM32 і не тільки :)*/

class Array {
private:
    int m_init_size; //поч. розмір масиву
    int m_growThStep;  //крок розшир.         
    int* m_arr_ptr; //вказ. на масив (змінна, значенням якої є адреса комірки в пам’яті)
    int m_curIndex; //curr
	int m_allocatedSize; //ємність масиву


    // Примітка: у хорошій практиці члени класу часто позначаються через префікс m_ (member)
    // Це дозволяє краще відрізняти їх від локальних змінних і параметрів функцій.

public:
    Array(int size = 10, int step = 5);  
    ~Array(); 

    //написати 2 конструктор в класі
    /*Array(int* arr, int size); // Конструктор створення на основі переданого масиву*/


    bool isEmpty() const;             // Перевірка на пустоту
    int getSize() const;                // Поточна ємність
    int getElemSize() const;            // Кількість збережених елементів
    void setValue(int val);             // Додати один елемент
    void setArray(int* pArr, int size); // Додати масив елементів
	void cleaning();                    // Очищення масиву
    void showElements() const;          // Вивід елементів
    void expandArray(int size);         // Розширення масиву


    /*метод(штуки з const) не змінює стан об'єкта. Тобто ці штуки лише читають дані, але не змінюють щось. 
    Тобто як росіяни, вони читають про трагедію, але нічого не змінюють*/
};

#endif

/*#ifdef end #define - механізм захисту від множинного включення, що забезпечує коректну компіляцію*/
/*#ifndef ARRAY_H — перевіряє, чи НЕ визначено макрос ARRAY_H. Якщо він ще не визначений, компілятор продовжує читати код далі.

#define ARRAY_H — визначає макрос ARRAY_H, щоб при наступному включенні цього ж файлу перевірка #ifndef ARRAY_H вже не пройшла, і код не оброблявся повторно.*/